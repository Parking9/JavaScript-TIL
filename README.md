# JavaScript TIL

> 기본적으로 **[모던 자바스크립트 Deep Dive](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=331405&barcode=9791158392239)**책을 기반으로 학습하며, 유튜브와 구글링을 통해 자료를 추가하였다.



## 1021

- print( 문서에 출력하기 - browser only)

  ```javascript
  document.write('문자열')
  ```

- User input ( 사용자 입력 받기 - browser only)

  ```javascript
  const UserName = prompt('who are you?')
  ```





### 스코프

> 어떤 변수들에 접근할 수 있는지를 정의한다.

​	**1) 전역 스코프(Global Scope)**

​	변수가 함수 바깥이나 중괄호(`{}`) 바깥에서 선언됐으면, 전역 스코프에 정의된다. *전역 변수는 코드 어디서든	지 사용가능하다.*  변수 이름의 중복을 유의하자

​	**2) 지역 스코프(Local Scope)**

​	특정 부분에서만 사용할 수 있는 변수.

​		2-1) 함수 스코프 (Function Scope)

​		함수 내부에서 변수를 선언하면, 그 변수는 선언한 함수 내부에서만 접근 가능하다. 함수 바깥에서 접근 불가.

​		2-2) 블록 스코프 (Block Scope)

​		중괄호 내부에서 변수를 선언하면, 그 변수들은 중괄호 블록 내부에서만 접근할 수 있다.

​		*함수를 선언할 때에는 중괄호를 사용해야 하므로, 블록 스코프는 함수 스코프의 서브셋이다.*



- 함수는 서로의 스코프에 접근할 수 없다.

- **네스팅된 스코프 ( Nested Scope) ** : 함수 안에 다른 함수가 내부에서 정의되었다면, 내부 함수는 외부 함수의 변수에 접근할 수 있다. 이런 행동을 렉시컬 스코핑(lexical scoping)이라고 부른다. *반면, 외부 함수는 내부 함수의 변수에 접근할 수 없다.*



#### 클로저 (Closures)

> 함수 내부에 **함수를 작성할 때 마다 내부에 작성된 함수** 즉, 클로져가 생성된다. 클로저는 외부 함수의 변수를 사용할 수 있기 때문에 대개 반환하여 사용한다.

- 클로저의 대표적인 두 가지 목적
  - 사이드 이펙트 (side effect ) 제어
    - 함수에서 값을 반환하는 것을 제외하고 무언가를 행할 때 사이드 이펙트가 발생한다. `Ajax`요청이나 `timeout`, 그리고 `console.log` 선언 등 모두 사이드 이펙트가 된다. 이를 클로져를 통해 사이드 이펙트를 제어한다.
  - private  변수 생성
    - 함수 내부의 변수는 함수 바깥에서 접근할 수 없어서 `private 변수`라고 불린다. 하지만, 해당 변수들에 접근해야 할 경우가 있는데, 이를 클로저를 통해서 접근할 수 있다.

<hr>
- Object Literal +

  object의 key와 value가 똑같다면, 마치 배열처럼 한 번만 작성 가능

  ex)

  ```javascript
  let books = array...;
  let comics = object...;
  let magazines = null;
  
  const bookShop={
      books,
      comics,
      magazines,
  };
  ```

  

- JSON은 실제로 Object 처럼 사용하려면 다른 언어들 처럼 Parsing(구문 분석) 작업이 필요하다.
  - **object => JSON** : JSON.stringify(Object)  / typeof로 확인하면 string
  - **JSON => object** : JSON.parse(JSON) / typeof로 확인하면 object



## 1022 JS의 특징, 변수

- `자바스크립트는` 프로그래밍 언어로서의 기본 뼈대를 이루는 `ECMASCript`와 브라우저가 별도 지원하는 `클라이언트 사이드 Web API`등을 아우르는 개념이다.
  - `클라이언트 사이드 Web API` : DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등



- 자바스크립트는 명령형(imperative), 함수형(functional), 프로토타입 기반 (prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.



- 자바스크립트는 별도의 컴파일 작업을 수행하지 않는 `인터프리터 언어(interpreter language)`이다. 대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점의 해결했다. 

  -> 전통적인 컴파일 언어 처럼 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실항한다.



#### 변수(Variavle)

>하나의 값을 저장하기 위해 확보한 메모리 공간 자체  또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 
>
>프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, **값의 위치를 가리키는 상징적인 이름을 말한다.**



- 컴퓨터는 메모리를 사용해 데이터를 기억한다. 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체로 메모리 셀 하나의 크기는 1바이트(8비트)이다. 즉 1 바이트 단위로 데이터를 저장하거나 읽어들인다. 각 셀은 고유의 메모리 주소를 갖고, 이 메모리 주소는 메모리 공간의 위치를 말한다. 컴퓨터는 모든 데이터를 2진수로 처리하는데 메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지, 동영상 등)와 상관없이 모두 2진수로 저장된다. 



- 데이터를 읽어오기 위하여 데이터가 저장된 메모리 공간에 직접 접근하는것은 치명적인 오류를 발생시킬 가능성이 높은 매우 위험한 일이다. 따라서 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 *값이 저장된 메모리 공간의 주소로 치환된 변수가 실행된다.*



- 새로운 데이터가 메모리 공간에 저장되고, 이 데이터를 다시 읽어 들여 재사용할 수 있도록 저장된 메모리 공간에 상징적인 이름을 붙인것이 바로 변수이다.
- 변수에 값을 저장하는 것을 할당 (assignment, 대입, 저장)이라고 하고, 변수에 저장된 값을 읽어 들이는 것을 참조 (reference)라고 한다. 



- 변수의 이름을 식별자(identifier)라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 값은 메모리 공간에 저장되어 있는데, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야한다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다. --> 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 
- 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.



- **변수 선언**은  변수를 생성하는 것을 말한다. 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다. 선언 `키워드`는 var, let , const이다.
  - `키워드`는 자바스크립트 코드를 해석하고 실행하는 JS엔진이 수행할 동작을 규정한 일종의 명령어다.
  - 변수를 선언만 하고 값을 할당하지 않으면 메모리 공간이 비어있어야하지만, 자바스크립트의 독특한 특징으로 `undefined`라는 값이 암묵적으로 할당되어 초기화 된다.